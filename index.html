<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM pricing calculator</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .calculator, .presets, .disclaimer {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        @media (min-width: 768px) {
            .flex-container {
                display: flex;
                gap: 20px;
            }
            .calculator {
                flex: 1;
            }
            .presets {
                flex: 2;
            }
        }
        h1, h2 {
            font-size: 24px;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
        }
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9f7ef;
            border-radius: 4px;
        }
        .result p {
            margin: 5px 0;
            font-size: 18px;
            color: #2ecc71;
        }
        .preset-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .preset-table th {
            background-color: #f2f2f2;
            padding: 10px;
            text-align: left;
            position: relative;
        }
        .preset-table th button {
            background: none;
            border: none;
            font-weight: bold;
            font-size: inherit;
            text-align: left;
            padding: 0;
            margin: 0;
            width: 100%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .preset-table th button:hover,
        .preset-table th button:focus {
            background-color: #e0e0e0;
            outline: 2px solid #0066cc;
        }
        .sort-icon {
            margin-left: 5px;
        }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        .preset-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #ddd;
        }
        .preset-table tr:hover {
            background-color: #f5f5f5;
        }
        .model-name-btn {
            background-color: #e1f0ff;
            border: 1px solid #d0e5fa;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            text-align: left;
            padding: 5px 8px;
            font-family: inherit;
            width: 100%;
            text-decoration: none;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .model-name-btn:hover,
        .model-name-btn:focus {
            background-color: #96bce0;
            border-color: #6a9ccf;
            outline: 2px solid #0066cc;
        }
        .disclaimer {
            font-size: 14px;
            color: #777;
            text-align: center;
            font-style: italic;
        }
        .search-filter {
            margin-bottom: 15px;
        }
        #modelSearch {
            width: 100%;
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 4px;
            font-size: 14px;
        }
        #modelSearch:focus {
            outline: 2px solid #0066cc;
            border-color: #0066cc;
        }
        #compareToggle {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #compareToggle.hidden {
            display: none;
        }
        #clearSelectionBtn:hover {
            background-color: #e0e0e0;
            border-color: #999;
        }
        #clearSelectionBtn:active {
            background-color: #d0d0d0;
        }
    </style>
    <script defer data-domain="llm-prices.com" src="https://plausible.io/js/script.js"></script>
</head>
<body>
    <div class="container">
        <div class="flex-container">
            <div class="calculator">
                <h1>LLM pricing calculator</h1>
                <div class="input-group">
                    <label for="inputTokens">Number of input tokens<br><span style="font-size: 0.85em; color: #666;">(aka prompt tokens)</span></label>
                    <input type="number" id="inputTokens" min="0">
                </div>
                <div class="input-group" id="cachedInputGroup">
                    <label for="cachedInputTokens">Number of cached input tokens</label>
                    <input type="number" id="cachedInputTokens" min="0">
                </div>
                <div class="input-group">
                    <label for="outputTokens">Number of output tokens<br><span style="font-size: 0.85em; color: #666;">(aka completion tokens)</span></label>
                    <input type="number" id="outputTokens" min="0">
                </div>
                <div class="input-group cost-input-group">
                    <label for="inputCost">Cost per million input tokens ($):</label>
                    <input type="number" id="inputCost" min="0" step="0.000001">
                </div>
                <div class="input-group cost-input-group">
                    <label for="cachedInputCost">Cost per million cached input tokens ($):</label>
                    <input type="number" id="cachedInputCost" min="0" step="0.000001">
                </div>
                <div class="input-group cost-input-group">
                    <label for="outputCost">Cost per million output tokens ($):</label>
                    <input type="number" id="outputCost" min="0" step="0.000001">
                </div>
                <div class="result" id="singleResult" style="display: none;">
                    <p>Total cost: <span id="costFormatted"></span></p>
                </div>
                <div id="multiModelResults" style="display: none; margin-top: 20px;">
                    <!-- Multi-model comparison results will appear here -->
                </div>
                <div style="margin-top: 20px; padding: 10px; background-color: #f9f9f9; border-radius: 4px; font-size: 12px; color: #666; font-style: italic;">
                    Note: Different models use different tokenizers, so direct token-based price comparisons may not be entirely accurate.
                </div>
            </div>

            <div class="presets">
                <h2>Model prices (per million tokens)</h2>
                <div class="search-filter">
                    <input type="search" id="modelSearch" placeholder="Search models..." aria-label="Search models">
                </div>
                <div id="compareToggle" class="hidden" style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="showOnlySelectedCheckbox">
                        <span>Show just selected</span>
                    </label>
                    <button type="button" id="clearSelectionBtn" style="padding: 6px 12px; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;">Clear selection</button>
                </div>
                <div id="presetTable">
                    <table class="preset-table">
                        <thead>
                            <tr>
                                <th aria-sort="none">
                                    <button type="button" id="sortByName">
                                        Model
                                        <span class="sort-icon" aria-hidden="true"></span>
                                    </button>
                                </th>
                                <th aria-sort="ascending"> <!-- Default sort visually, JS will confirm -->
                                    <button type="button" id="sortByInput">
                                        Input cost
                                        <span style="font-size: 0.85em; color: #666; font-weight: normal;">(Cached)</span>
                                        <span class="sort-icon" aria-hidden="true">↑</span>
                                    </button>
                                </th>
                                <th aria-sort="none">
                                    <button type="button" id="sortByOutput">
                                        Output cost
                                        <span class="sort-icon" aria-hidden="true"></span>
                                    </button>
                                </th>
                                <th>Compare</th>
                            </tr>
                        </thead>
                        <tbody id="presetTableBody">
                            <!-- Table rows will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="disclaimer">
            Prices last updated: <span id="lastUpdated">Loading...</span>
            <br>
            <a href="https://github.com/simonw/llm-prices" target="_blank" rel="noopener noreferrer">View source on GitHub</a>
        </div>
    </div>

    <script>
        // Prices are $ per 1M tokens - loaded from models.json
        let presets = {};

        // Global state variables for sorting
        let currentSortColumn = 'input'; // Default sort column: 'name', 'input', or 'output'
        let currentSortDirection = 'ascending'; // 'ascending' or 'descending'
        let currentSearchTerm = ''; // Current search filter

        // Global state variables for comparison
        let selectedModels = new Set(); // Set of selected model keys
        let showOnlySelected = false; // Whether to show only selected models

        // Form field IDs
        const elIds = {
            inputTokens: 'inputTokens',
            cachedInputTokens: 'cachedInputTokens',
            outputTokens: 'outputTokens',
            inputCost: 'inputCost',
            cachedInputCost: 'cachedInputCost',
            outputCost: 'outputCost',
            costFormatted: 'costFormatted',
            presetTableBody: 'presetTableBody',
            sortByName: 'sortByName',
            sortByInput: 'sortByInput',
            sortByOutput: 'sortByOutput'
        };

        // Hash parameter keys (short for brevity in URL)
        const HASH_KEYS = {
            inputTokens: 'it',
            cachedInputTokens: 'cit',
            outputTokens: 'ot',
            inputCost: 'ic',
            cachedInputCost: 'cic',
            outputCost: 'oc',
            sortBy: 'sb',
            sortDir: 'sd',
            selected: 'sel'
        };

        function updateUrlHash() {
            const params = new URLSearchParams();
            const inputTokensVal = document.getElementById(elIds.inputTokens).value;
            const cachedInputTokensVal = document.getElementById(elIds.cachedInputTokens).value;
            const outputTokensVal = document.getElementById(elIds.outputTokens).value;
            const inputCostVal = document.getElementById(elIds.inputCost).value;
            const cachedInputCostVal = document.getElementById(elIds.cachedInputCost).value;
            const outputCostVal = document.getElementById(elIds.outputCost).value;

            if (inputTokensVal && parseFloat(inputTokensVal) !== 0) params.set(HASH_KEYS.inputTokens, inputTokensVal);
            if (cachedInputTokensVal && parseFloat(cachedInputTokensVal) !== 0) params.set(HASH_KEYS.cachedInputTokens, cachedInputTokensVal);
            if (outputTokensVal && parseFloat(outputTokensVal) !== 0) params.set(HASH_KEYS.outputTokens, outputTokensVal);
            if (inputCostVal && parseFloat(inputCostVal) !== 0) params.set(HASH_KEYS.inputCost, inputCostVal);
            if (cachedInputCostVal && parseFloat(cachedInputCostVal) !== 0) params.set(HASH_KEYS.cachedInputCost, cachedInputCostVal);
            if (outputCostVal && parseFloat(outputCostVal) !== 0) params.set(HASH_KEYS.outputCost, outputCostVal);

            // Only add sort params if not the default sort to keep URL cleaner for default state
            if (!(currentSortColumn === 'input' && currentSortDirection === 'ascending')) {
                 params.set(HASH_KEYS.sortBy, currentSortColumn);
                 params.set(HASH_KEYS.sortDir, currentSortDirection);
            }

            // Add selected models if any
            if (selectedModels.size > 0) {
                params.set(HASH_KEYS.selected, Array.from(selectedModels).join(','));
            }

            const hashString = params.toString();
            if (hashString) {
                history.replaceState(null, '', '#' + hashString);
            } else {
                history.replaceState(null, '', window.location.pathname + window.location.search);
            }
        }

        function updateCalculatorMode() {
            const costInputGroups = document.querySelectorAll('.cost-input-group');
            const singleResultDiv = document.getElementById('singleResult');
            const multiResultDiv = document.getElementById('multiModelResults');
            const cachedInputGroup = document.getElementById('cachedInputGroup');

            if (selectedModels.size > 0) {
                // Comparison mode: hide cost inputs, show multi-model results
                costInputGroups.forEach(group => group.style.display = 'none');
                singleResultDiv.style.display = 'none';
                multiResultDiv.style.display = 'block';

                // Check if any selected model has cached pricing
                const hasCachedPricing = Array.from(selectedModels).some(key => {
                    const model = presets[key];
                    return model && model.input_cached !== null && model.input_cached !== undefined;
                });

                // Show/hide cached input tokens field based on whether any model supports it
                cachedInputGroup.style.display = hasCachedPricing ? 'block' : 'none';
            } else {
                // Normal mode: show cost inputs, let calculateCost() handle single result visibility
                costInputGroups.forEach(group => group.style.display = 'block');
                multiResultDiv.style.display = 'none';
                cachedInputGroup.style.display = 'block'; // Always show in normal mode
            }
            calculateCost();
        }

        function calculateCost() {
            const inputTokens = parseFloat(document.getElementById(elIds.inputTokens).value) || 0;
            const cachedInputTokens = parseFloat(document.getElementById(elIds.cachedInputTokens).value) || 0;
            const outputTokens = parseFloat(document.getElementById(elIds.outputTokens).value) || 0;

            if (selectedModels.size > 0) {
                // Multi-model comparison mode
                const multiResultDiv = document.getElementById('multiModelResults');
                let html = '<div style="padding: 15px; background-color: #e9f7ef; border-radius: 4px;">';

                const sortedModels = Array.from(selectedModels).map(key => ({
                    key: key,
                    ...presets[key]
                })).sort((a, b) => {
                    const costA = (inputTokens * a.input / 1000000) +
                                 (cachedInputTokens * (a.input_cached || a.input) / 1000000) +
                                 (outputTokens * a.output / 1000000);
                    const costB = (inputTokens * b.input / 1000000) +
                                 (cachedInputTokens * (b.input_cached || b.input) / 1000000) +
                                 (outputTokens * b.output / 1000000);
                    return costA - costB;
                });

                // Find cheapest input and output prices for multiplier display
                let minInputPrice = Infinity;
                let minOutputPrice = Infinity;
                let minInputModel = null;
                let minOutputModel = null;

                sortedModels.forEach(model => {
                    if (model.input < minInputPrice) {
                        minInputPrice = model.input;
                        minInputModel = model;
                    }
                    if (model.output < minOutputPrice) {
                        minOutputPrice = model.output;
                        minOutputModel = model;
                    }
                });

                sortedModels.forEach(model => {
                    const inputCost = model.input;
                    const cachedInputCost = model.input_cached || model.input;
                    const outputCost = model.output;
                    const totalCost = (inputTokens * inputCost / 1000000) +
                                     (cachedInputTokens * cachedInputCost / 1000000) +
                                     (outputTokens * outputCost / 1000000);

                    html += `<div style="margin-bottom: 10px; padding: 10px; background-color: white; border-radius: 4px;">`;
                    html += `<div style="font-weight: bold; margin-bottom: 5px;">${model.name}</div>`;
                    html += `<div style="font-size: 12px; color: #666; margin-bottom: 5px;">`;
                    html += `Input: ${formatPrice(inputCost)}/M`;
                    if (model.input_cached) {
                        html += ` (Cached: ${formatPrice(cachedInputCost)}/M)`;
                    }
                    html += ` | Output: ${formatPrice(outputCost)}/M`;
                    html += `</div>`;

                    // Show price multipliers when 2+ models selected
                    if (selectedModels.size >= 2 && (inputCost > minInputPrice || outputCost > minOutputPrice)) {
                        const inputMultiplier = inputCost / minInputPrice;
                        const outputMultiplier = outputCost / minOutputPrice;

                        let multiplierParts = [];
                        if (inputCost > minInputPrice) {
                            multiplierParts.push(`${trimZeros(inputMultiplier.toFixed(2))}x input vs ${minInputModel.name}`);
                        }
                        if (outputCost > minOutputPrice) {
                            const outputRef = minOutputModel.key === minInputModel.key ? '' : ` vs ${minOutputModel.name}`;
                            multiplierParts.push(`${trimZeros(outputMultiplier.toFixed(2))}x output${outputRef}`);
                        }

                        if (multiplierParts.length > 0) {
                            html += `<div style="font-size: 11px; color: #999; margin-bottom: 5px; font-style: italic;">`;
                            html += multiplierParts.join(', ');
                            html += `</div>`;
                        }
                    }

                    // Only show cost if tokens have been entered
                    if (inputTokens > 0 || cachedInputTokens > 0 || outputTokens > 0) {
                        html += `<div style="font-size: 18px; color: #2ecc71; font-weight: bold;">`;
                        html += formatCost(totalCost);
                        html += `</div>`;
                    }
                    html += `</div>`;
                });

                html += '</div>';
                multiResultDiv.innerHTML = html;
            } else {
                // Single model mode
                const inputCost = parseFloat(document.getElementById(elIds.inputCost).value) || 0;
                const cachedInputCost = parseFloat(document.getElementById(elIds.cachedInputCost).value) || 0;
                const outputCost = parseFloat(document.getElementById(elIds.outputCost).value) || 0;

                const totalCost = (inputTokens * inputCost / 1000000) + (cachedInputTokens * cachedInputCost / 1000000) + (outputTokens * outputCost / 1000000);

                // Only show the result box if both tokens AND costs have been entered
                // (single model mode requires user to input both, unlike multi-model mode where costs come from presets)
                const hasTokens = inputTokens > 0 || cachedInputTokens > 0 || outputTokens > 0;
                const hasCosts = inputCost > 0 || cachedInputCost > 0 || outputCost > 0;
                const singleResultDiv = document.getElementById('singleResult');
                if (hasTokens && hasCosts) {
                    document.getElementById(elIds.costFormatted).textContent = formatCost(totalCost);
                    singleResultDiv.style.display = 'block';
                } else {
                    singleResultDiv.style.display = 'none';
                }
            }
            updateUrlHash();
        }

        function trimZeros(numStr) {
            return numStr.replace(/\.?0+$/, '');
        }

        function formatCost(totalCost) {
            const dollars = trimZeros(totalCost.toFixed(6));
            if (totalCost >= 1) {
                return `$${dollars}`;
            } else {
                const cents = trimZeros((totalCost * 100).toFixed(4));
                return `$${dollars} (${cents} cents)`;
            }
        }

        function setPreset(modelKey) {
            const preset = presets[modelKey];
            if (!preset) return;

            document.getElementById(elIds.inputCost).value = preset.input;
            document.getElementById(elIds.cachedInputCost).value = preset.input_cached || '';
            document.getElementById(elIds.outputCost).value = preset.output;
            calculateCost(); // This will also call updateUrlHash
        }

        function formatPrice(price) {
            if (Number.isInteger(price)) return `$${price}`;
            const priceStr = price.toString();
            if (priceStr.split('.')[1]?.length > 2 && !priceStr.endsWith('0')) return `$${priceStr}`;
            return `$${price.toFixed(2)}`;
        }

        function matchesSearch(modelName, searchTerm) {
            if (!searchTerm) return true;

            // Split search term on spaces and create regex pattern
            const terms = searchTerm.trim().split(/\s+/).filter(t => t.length > 0);
            if (terms.length === 0) return true;

            // Escape special regex characters in each term
            const escapedTerms = terms.map(term =>
                term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
            );

            // Create pattern: first-term.*next-term.*last-term
            const pattern = escapedTerms.join('.*');
            const regex = new RegExp(pattern, 'i'); // case-insensitive

            return regex.test(modelName);
        }

        function getSortedPresetList(sortCol, sortDir) {
            const presetList = [];
            for (const [key, preset] of Object.entries(presets)) {
                // Apply search filter
                if (!matchesSearch(preset.name, currentSearchTerm)) {
                    continue;
                }

                // Apply "show only selected" filter
                if (showOnlySelected && !selectedModels.has(key)) {
                    continue;
                }

                presetList.push({
                    key: key,
                    name: preset.name,
                    input: preset.input,
                    output: preset.output,
                    input_cached: preset.input_cached
                });
            }

            presetList.sort((a, b) => {
                let valA, valB;
                if (sortCol === 'name') {
                    valA = a.name.toLowerCase(); // Case-insensitive sort for names
                    valB = b.name.toLowerCase();
                    if (valA < valB) return sortDir === 'ascending' ? -1 : 1;
                    if (valA > valB) return sortDir === 'ascending' ? 1 : -1;
                    return 0;
                } else if (sortCol === 'input') {
                    valA = a.input;
                    valB = b.input;
                } else if (sortCol === 'output') {
                    valA = a.output;
                    valB = b.output;
                } else {
                    return 0; // Should not happen with valid sortCol
                }

                return sortDir === 'ascending' ? valA - valB : valB - valA;
            });
            return presetList;
        }

        function renderTable(data) {
            const presetTableBody = document.getElementById(elIds.presetTableBody);
            presetTableBody.innerHTML = ''; // Clear existing rows

            data.forEach(item => {
                const row = document.createElement('tr');
                // Format input cost with cached price if available
                let inputCostDisplay = formatPrice(item.input);
                if (item.input_cached !== null && item.input_cached !== undefined) {
                    inputCostDisplay += ` <span style="font-size: 0.85em; color: #666;">(${formatPrice(item.input_cached)})</span>`;
                }
                // Note: onclick now calls window.setPreset because these are dynamically added
                row.innerHTML = `
                    <td><button class="model-name-btn" onclick="window.setPreset('${item.key}')">${item.name}</button></td>
                    <td>${inputCostDisplay}</td>
                    <td>${formatPrice(item.output)}</td>
                    <td><input type="checkbox" class="compare-checkbox" data-model-key="${item.key}" ${selectedModels.has(item.key) ? 'checked' : ''}></td>
                `;
                presetTableBody.appendChild(row);
            });

            // Add event listeners to checkboxes
            const checkboxes = presetTableBody.querySelectorAll('.compare-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', handleCheckboxChange);
            });

            // Add click handlers to rows for toggling checkboxes
            const rows = presetTableBody.querySelectorAll('tr');
            rows.forEach(row => {
                row.addEventListener('click', handleRowClick);
                row.style.cursor = 'pointer';
            });
        }

        function handleRowClick(event) {
            // Don't toggle if clicking on the model name button or the checkbox itself
            if (event.target.closest('.model-name-btn') || event.target.classList.contains('compare-checkbox')) {
                return;
            }

            // Find the checkbox in this row
            const checkbox = event.currentTarget.querySelector('.compare-checkbox');
            if (checkbox) {
                // Toggle the checkbox
                checkbox.checked = !checkbox.checked;
                // Trigger the change event
                checkbox.dispatchEvent(new Event('change'));
            }
        }

        function handleCheckboxChange(event) {
            const checkbox = event.target;
            const modelKey = checkbox.dataset.modelKey;

            if (checkbox.checked) {
                selectedModels.add(modelKey);
            } else {
                selectedModels.delete(modelKey);
            }

            updateCompareToggleVisibility();
            updateCalculatorMode();
            updateUrlHash();
        }

        function updateCompareToggleVisibility() {
            const compareToggle = document.getElementById('compareToggle');
            if (selectedModels.size >= 1) {
                compareToggle.classList.remove('hidden');
            } else {
                compareToggle.classList.add('hidden');
                // If no models selected, turn off "show only selected" mode
                if (showOnlySelected) {
                    showOnlySelected = false;
                    document.getElementById('showOnlySelectedCheckbox').checked = false;
                    updateTableSortVisualsAndData();
                }
            }
        }

        function handleShowOnlySelectedChange(event) {
            showOnlySelected = event.target.checked;

            // Clear search filter if it has text
            const searchInput = document.getElementById('modelSearch');
            if (searchInput.value) {
                searchInput.value = '';
                currentSearchTerm = '';
            }

            updateTableSortVisualsAndData();
        }

        function updateTableSortVisualsAndData() {
            const thElements = document.querySelectorAll('.preset-table th');
            thElements.forEach(th => {
                th.setAttribute('aria-sort', 'none');
                const sortIcon = th.querySelector('.sort-icon');
                if (sortIcon) {
                    sortIcon.textContent = '';
                }
            });

            let activeThButtonId;
            if (currentSortColumn === 'name') activeThButtonId = elIds.sortByName;
            else if (currentSortColumn === 'input') activeThButtonId = elIds.sortByInput;
            else if (currentSortColumn === 'output') activeThButtonId = elIds.sortByOutput;

            if (activeThButtonId) {
                const activeTh = document.getElementById(activeThButtonId)?.closest('th');
                if (activeTh) {
                    activeTh.setAttribute('aria-sort', currentSortDirection);
                    activeTh.querySelector('.sort-icon').textContent = (currentSortDirection === 'ascending') ? '↑' : '↓';
                }
            }

            const sortedList = getSortedPresetList(currentSortColumn, currentSortDirection);
            renderTable(sortedList);
        }

        function sortTable(column) {
            if (currentSortColumn === column) {
                currentSortDirection = (currentSortDirection === 'ascending') ? 'descending' : 'ascending';
            } else {
                currentSortColumn = column;
                // Default direction for a new column (name: asc, numeric: asc)
                currentSortDirection = 'ascending';
            }
            updateTableSortVisualsAndData();
            updateUrlHash();
        }

        function applyStateFromHash() {
            if (!window.location.hash || window.location.hash === '#') {
                return; // No hash, use defaults
            }

            const params = new URLSearchParams(window.location.hash.substring(1));

            const inputTokensEl = document.getElementById(elIds.inputTokens);
            const cachedInputTokensEl = document.getElementById(elIds.cachedInputTokens);
            const outputTokensEl = document.getElementById(elIds.outputTokens);
            const inputCostEl = document.getElementById(elIds.inputCost);
            const cachedInputCostEl = document.getElementById(elIds.cachedInputCost);
            const outputCostEl = document.getElementById(elIds.outputCost);

            if (params.has(HASH_KEYS.inputTokens)) inputTokensEl.value = params.get(HASH_KEYS.inputTokens);
            if (params.has(HASH_KEYS.cachedInputTokens)) cachedInputTokensEl.value = params.get(HASH_KEYS.cachedInputTokens);
            if (params.has(HASH_KEYS.outputTokens)) outputTokensEl.value = params.get(HASH_KEYS.outputTokens);
            if (params.has(HASH_KEYS.inputCost)) inputCostEl.value = params.get(HASH_KEYS.inputCost);
            if (params.has(HASH_KEYS.cachedInputCost)) cachedInputCostEl.value = params.get(HASH_KEYS.cachedInputCost);
            if (params.has(HASH_KEYS.outputCost)) outputCostEl.value = params.get(HASH_KEYS.outputCost);

            const sortByFromHash = params.get(HASH_KEYS.sortBy);
            const sortDirFromHash = params.get(HASH_KEYS.sortDir);

            // Valid sort columns and directions
            const validSortCols = ['name', 'input', 'output'];
            const validSortDirs = ['ascending', 'descending'];

            if (sortByFromHash && validSortCols.includes(sortByFromHash) &&
                sortDirFromHash && validSortDirs.includes(sortDirFromHash)) {
                currentSortColumn = sortByFromHash;
                currentSortDirection = sortDirFromHash;
            } else if (sortByFromHash || sortDirFromHash) {
                // If partial or invalid sort params, revert to default to avoid broken state
                currentSortColumn = 'input';
                currentSortDirection = 'ascending';
            }
            // If no sort params in hash, defaults currentSortColumn/Direction are used

            // Restore selected models
            if (params.has(HASH_KEYS.selected)) {
                const selectedStr = params.get(HASH_KEYS.selected);
                if (selectedStr) {
                    selectedModels = new Set(selectedStr.split(',').filter(key => key.length > 0));
                }
            }
        }

        function handleSearchInput(event) {
            currentSearchTerm = event.target.value;
            updateTableSortVisualsAndData();
        }

        function handleSearchKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                // Find the first model button in the table and click it
                const firstModelButton = document.querySelector('#presetTableBody .model-name-btn');
                if (firstModelButton) {
                    firstModelButton.click();
                }
            }
        }

        function createPresetsTableStructure() {
            // Event listeners for sort buttons
            document.getElementById(elIds.sortByName).addEventListener('click', () => sortTable('name'));
            document.getElementById(elIds.sortByInput).addEventListener('click', () => sortTable('input'));
            document.getElementById(elIds.sortByOutput).addEventListener('click', () => sortTable('output'));

            // Event listeners for search input
            const searchInput = document.getElementById('modelSearch');
            searchInput.addEventListener('input', handleSearchInput);
            searchInput.addEventListener('keydown', handleSearchKeydown);

            // Event listener for "show only selected" checkbox
            const showOnlySelectedCheckbox = document.getElementById('showOnlySelectedCheckbox');
            showOnlySelectedCheckbox.addEventListener('change', handleShowOnlySelectedChange);

            // Event listener for "clear selection" button
            const clearSelectionBtn = document.getElementById('clearSelectionBtn');
            clearSelectionBtn.addEventListener('click', handleClearSelection);

            // Initial render based on currentSortColumn and currentSortDirection
            // (which might have been updated by applyStateFromHash)
            updateTableSortVisualsAndData();
            updateCompareToggleVisibility();
        }

        function handleClearSelection() {
            selectedModels.clear();
            showOnlySelected = false;
            document.getElementById('showOnlySelectedCheckbox').checked = false;
            updateTableSortVisualsAndData();
            updateCompareToggleVisibility();
            updateCalculatorMode();
            updateUrlHash();
        }

        function handlePaste(event) {
            const text = (event.clipboardData || window.clipboardData).getData('text');
            const comboMatch = text.match(/([\d,]+)\s*input[, ]+([\d,]+)\s*output/i);
            if (comboMatch) {
                event.preventDefault();
                document.getElementById(elIds.inputTokens).value = comboMatch[1].replace(/,/g, '');
                document.getElementById(elIds.outputTokens).value = comboMatch[2].replace(/,/g, '');
                calculateCost();
                return;
            }
            const numMatch = text.match(/^\s*([\d,]+)\s*$/);
            if (numMatch && event.target.type === 'number') { // Ensure it's a number input
                event.preventDefault();
                event.target.value = numMatch[1].replace(/,/g, '');
                // Manually trigger 'input' event if needed, or just calculate
                calculateCost();
            }
        }

        // Load models from current.json
        async function loadModels() {
            try {
                const response = await fetch('current-v1.json');
                const data = await response.json();

                // Convert prices array to object with id as the key
                presets = {};
                data.prices.forEach(model => {
                    presets[model.id] = {
                        name: model.name,
                        input: model.input,
                        output: model.output,
                        input_cached: model.input_cached
                    };
                });

                // Update the last updated date in the footer
                if (data.updated_at) {
                    document.getElementById('lastUpdated').textContent = data.updated_at;
                }

                return true;
            } catch (error) {
                console.error('Error loading models:', error);
                document.getElementById('lastUpdated').textContent = 'Unknown';
                return false;
            }
        }

        // Make setPreset globally accessible for dynamically created buttons
        window.setPreset = setPreset;

        // Initialize on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', async () => {
            await loadModels();        // 0. Load models from JSON first
            applyStateFromHash();      // 1. Apply state from URL hash first (updates globals)
            createPresetsTableStructure(); // 2. Setup table structure & initial render using (potentially updated) globals
            updateCalculatorMode();    // 3. Set calculator mode based on selections
            calculateCost();           // 4. Initial calculation and URL hash update based on current state

            // Add event listeners to form inputs
            const formInputs = [elIds.inputTokens, elIds.cachedInputTokens, elIds.outputTokens, elIds.inputCost, elIds.cachedInputCost, elIds.outputCost];
            formInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', calculateCost);
                // Add paste listener only to token inputs as per original logic
                if (id === elIds.inputTokens || id === elIds.cachedInputTokens || id === elIds.outputTokens) {
                     document.getElementById(id).addEventListener('paste', handlePaste);
                } else {
                     document.getElementById(id).addEventListener('paste', (e) => {
                         // Basic paste handling for cost inputs if desired, or just let browser handle
                         setTimeout(calculateCost, 0); // Recalculate after paste
                     });
                }
            });
            // Specific paste handler for inputTokens - remove from generic loop if it's only for one.
            // Original code had it only for inputTokens. Let's keep it for inputTokens only for now.
            document.getElementById(elIds.inputTokens).removeEventListener('paste', handlePaste); // remove generic one
            document.getElementById(elIds.inputTokens).addEventListener('paste', handlePaste); // add specific one

        });
    </script>
</body>
</html>

