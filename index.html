<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM pricing calculator</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .calculator, .presets, .disclaimer {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        @media (min-width: 768px) {
            .flex-container {
                display: flex;
                gap: 20px;
            }
            .calculator {
                flex: 1;
            }
            .presets {
                flex: 2;
            }
        }
        h1, h2 {
            font-size: 24px;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
        }
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9f7ef;
            border-radius: 4px;
        }
        .result p {
            margin: 5px 0;
            font-size: 18px;
            color: #2ecc71;
        }
        .preset-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .preset-table th {
            background-color: #f2f2f2;
            padding: 10px;
            text-align: left;
            position: relative;
        }
        .preset-table th button {
            background: none;
            border: none;
            font-weight: bold;
            font-size: inherit;
            text-align: left;
            padding: 0;
            margin: 0;
            width: 100%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .preset-table th button:hover,
        .preset-table th button:focus {
            background-color: #e0e0e0;
            outline: 2px solid #0066cc;
        }
        .sort-icon {
            margin-left: 5px;
        }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        .preset-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #ddd;
        }
        .preset-table tr:hover {
            background-color: #f5f5f5;
        }
        .model-name-btn {
            background-color: #e1f0ff;
            border: 1px solid #d0e5fa;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            text-align: left;
            padding: 5px 8px;
            font-family: inherit;
            width: 100%;
            text-decoration: none;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .model-name-btn:hover,
        .model-name-btn:focus {
            background-color: #96bce0;
            border-color: #6a9ccf;
            outline: 2px solid #0066cc;
        }
        .disclaimer {
            font-size: 14px;
            color: #777;
            text-align: center;
            font-style: italic;
        }
        .search-filter {
            margin-bottom: 15px;
        }
        #modelSearch {
            width: 100%;
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 4px;
            font-size: 14px;
        }
        #modelSearch:focus {
            outline: 2px solid #0066cc;
            border-color: #0066cc;
        }
    </style>
    <script defer data-domain="llm-prices.com" src="https://plausible.io/js/script.js"></script>
</head>
<body>
    <div class="container">
        <div class="flex-container">
            <div class="calculator">
                <h1>LLM pricing calculator</h1>
                <div class="input-group">
                    <label for="inputTokens">Number of input tokens<br><span style="font-size: 0.85em; color: #666;">(aka prompt tokens)</span></label>
                    <input type="number" id="inputTokens" min="0">
                </div>
                <div class="input-group">
                    <label for="cachedInputTokens">Number of cached input tokens</label>
                    <input type="number" id="cachedInputTokens" min="0">
                </div>
                <div class="input-group">
                    <label for="outputTokens">Number of output tokens<br><span style="font-size: 0.85em; color: #666;">(aka completion tokens)</span></label>
                    <input type="number" id="outputTokens" min="0">
                </div>
                <div class="input-group">
                    <label for="inputCost">Cost per million input tokens ($):</label>
                    <input type="number" id="inputCost" min="0" step="0.000001">
                </div>
                <div class="input-group">
                    <label for="cachedInputCost">Cost per million cached input tokens ($):</label>
                    <input type="number" id="cachedInputCost" min="0" step="0.000001">
                </div>
                <div class="input-group">
                    <label for="outputCost">Cost per million output tokens ($):</label>
                    <input type="number" id="outputCost" min="0" step="0.000001">
                </div>
                <div class="result">
                    <p>Total cost: $<span id="costDollars">0.000000</span></p>
                    <p>Total cost: <span id="costCents">0</span> cents</p>
                </div>
            </div>

            <div class="presets">
                <h2>Model prices (per million tokens)</h2>
                <div class="search-filter">
                    <input type="search" id="modelSearch" placeholder="Search models..." aria-label="Search models">
                </div>
                <div id="presetTable">
                    <table class="preset-table">
                        <thead>
                            <tr>
                                <th aria-sort="none">
                                    <button type="button" id="sortByName">
                                        Model
                                        <span class="sort-icon" aria-hidden="true"></span>
                                    </button>
                                </th>
                                <th aria-sort="ascending"> <!-- Default sort visually, JS will confirm -->
                                    <button type="button" id="sortByInput">
                                        Input cost
                                        <span style="font-size: 0.85em; color: #666; font-weight: normal;">(Cached input cost)</span>
                                        <span class="sort-icon" aria-hidden="true">↑</span>
                                    </button>
                                </th>
                                <th aria-sort="none">
                                    <button type="button" id="sortByOutput">
                                        Output cost
                                        <span class="sort-icon" aria-hidden="true"></span>
                                    </button>
                                </th>
                            </tr>
                        </thead>
                        <tbody id="presetTableBody">
                            <!-- Table rows will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="disclaimer">
            Prices last updated: <span id="lastUpdated">Loading...</span>
            <br>
            <a href="https://github.com/simonw/llm-prices" target="_blank" rel="noopener noreferrer">View source on GitHub</a>
        </div>
    </div>

    <script>
        // Prices are $ per 1M tokens - loaded from models.json
        let presets = {};

        // Global state variables for sorting
        let currentSortColumn = 'input'; // Default sort column: 'name', 'input', or 'output'
        let currentSortDirection = 'ascending'; // 'ascending' or 'descending'
        let currentSearchTerm = ''; // Current search filter

        // Form field IDs
        const elIds = {
            inputTokens: 'inputTokens',
            cachedInputTokens: 'cachedInputTokens',
            outputTokens: 'outputTokens',
            inputCost: 'inputCost',
            cachedInputCost: 'cachedInputCost',
            outputCost: 'outputCost',
            costDollars: 'costDollars',
            costCents: 'costCents',
            presetTableBody: 'presetTableBody',
            sortByName: 'sortByName',
            sortByInput: 'sortByInput',
            sortByOutput: 'sortByOutput'
        };

        // Hash parameter keys (short for brevity in URL)
        const HASH_KEYS = {
            inputTokens: 'it',
            cachedInputTokens: 'cit',
            outputTokens: 'ot',
            inputCost: 'ic',
            cachedInputCost: 'cic',
            outputCost: 'oc',
            sortBy: 'sb',
            sortDir: 'sd'
        };

        function updateUrlHash() {
            const params = new URLSearchParams();
            const inputTokensVal = document.getElementById(elIds.inputTokens).value;
            const cachedInputTokensVal = document.getElementById(elIds.cachedInputTokens).value;
            const outputTokensVal = document.getElementById(elIds.outputTokens).value;
            const inputCostVal = document.getElementById(elIds.inputCost).value;
            const cachedInputCostVal = document.getElementById(elIds.cachedInputCost).value;
            const outputCostVal = document.getElementById(elIds.outputCost).value;

            if (inputTokensVal && parseFloat(inputTokensVal) !== 0) params.set(HASH_KEYS.inputTokens, inputTokensVal);
            if (cachedInputTokensVal && parseFloat(cachedInputTokensVal) !== 0) params.set(HASH_KEYS.cachedInputTokens, cachedInputTokensVal);
            if (outputTokensVal && parseFloat(outputTokensVal) !== 0) params.set(HASH_KEYS.outputTokens, outputTokensVal);
            if (inputCostVal && parseFloat(inputCostVal) !== 0) params.set(HASH_KEYS.inputCost, inputCostVal);
            if (cachedInputCostVal && parseFloat(cachedInputCostVal) !== 0) params.set(HASH_KEYS.cachedInputCost, cachedInputCostVal);
            if (outputCostVal && parseFloat(outputCostVal) !== 0) params.set(HASH_KEYS.outputCost, outputCostVal);

            // Only add sort params if not the default sort to keep URL cleaner for default state
            if (!(currentSortColumn === 'input' && currentSortDirection === 'ascending')) {
                 params.set(HASH_KEYS.sortBy, currentSortColumn);
                 params.set(HASH_KEYS.sortDir, currentSortDirection);
            }

            const hashString = params.toString();
            if (hashString) {
                history.replaceState(null, '', '#' + hashString);
            } else {
                history.replaceState(null, '', window.location.pathname + window.location.search);
            }
        }

        function calculateCost() {
            const inputTokens = parseFloat(document.getElementById(elIds.inputTokens).value) || 0;
            const cachedInputTokens = parseFloat(document.getElementById(elIds.cachedInputTokens).value) || 0;
            const outputTokens = parseFloat(document.getElementById(elIds.outputTokens).value) || 0;
            const inputCost = parseFloat(document.getElementById(elIds.inputCost).value) || 0;
            const cachedInputCost = parseFloat(document.getElementById(elIds.cachedInputCost).value) || 0;
            const outputCost = parseFloat(document.getElementById(elIds.outputCost).value) || 0;

            const totalCost = (inputTokens * inputCost / 1000000) + (cachedInputTokens * cachedInputCost / 1000000) + (outputTokens * outputCost / 1000000);

            document.getElementById(elIds.costDollars).textContent = totalCost.toFixed(6);
            document.getElementById(elIds.costCents).textContent = trimZeros((totalCost * 100).toFixed(4));
            updateUrlHash();
        }

        function trimZeros(numStr) {
            return numStr.replace(/\.?0+$/, '');
        }

        function setPreset(modelKey) {
            const preset = presets[modelKey];
            if (!preset) return;

            document.getElementById(elIds.inputCost).value = preset.input;
            document.getElementById(elIds.cachedInputCost).value = preset.input_cached || '';
            document.getElementById(elIds.outputCost).value = preset.output;
            calculateCost(); // This will also call updateUrlHash
        }

        function formatPrice(price) {
            if (Number.isInteger(price)) return `$${price}`;
            const priceStr = price.toString();
            if (priceStr.split('.')[1]?.length > 2 && !priceStr.endsWith('0')) return `$${priceStr}`;
            return `$${price.toFixed(2)}`;
        }

        function matchesSearch(modelName, searchTerm) {
            if (!searchTerm) return true;

            // Split search term on spaces and create regex pattern
            const terms = searchTerm.trim().split(/\s+/).filter(t => t.length > 0);
            if (terms.length === 0) return true;

            // Escape special regex characters in each term
            const escapedTerms = terms.map(term =>
                term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
            );

            // Create pattern: first-term.*next-term.*last-term
            const pattern = escapedTerms.join('.*');
            const regex = new RegExp(pattern, 'i'); // case-insensitive

            return regex.test(modelName);
        }

        function getSortedPresetList(sortCol, sortDir) {
            const presetList = [];
            for (const [key, preset] of Object.entries(presets)) {
                // Apply search filter
                if (!matchesSearch(preset.name, currentSearchTerm)) {
                    continue;
                }

                presetList.push({
                    key: key,
                    name: preset.name,
                    input: preset.input,
                    output: preset.output,
                    input_cached: preset.input_cached
                });
            }

            presetList.sort((a, b) => {
                let valA, valB;
                if (sortCol === 'name') {
                    valA = a.name.toLowerCase(); // Case-insensitive sort for names
                    valB = b.name.toLowerCase();
                    if (valA < valB) return sortDir === 'ascending' ? -1 : 1;
                    if (valA > valB) return sortDir === 'ascending' ? 1 : -1;
                    return 0;
                } else if (sortCol === 'input') {
                    valA = a.input;
                    valB = b.input;
                } else if (sortCol === 'output') {
                    valA = a.output;
                    valB = b.output;
                } else {
                    return 0; // Should not happen with valid sortCol
                }

                return sortDir === 'ascending' ? valA - valB : valB - valA;
            });
            return presetList;
        }

        function renderTable(data) {
            const presetTableBody = document.getElementById(elIds.presetTableBody);
            presetTableBody.innerHTML = ''; // Clear existing rows

            data.forEach(item => {
                const row = document.createElement('tr');
                // Format input cost with cached price if available
                let inputCostDisplay = formatPrice(item.input);
                if (item.input_cached !== null && item.input_cached !== undefined) {
                    inputCostDisplay += ` <span style="font-size: 0.85em; color: #666;">(${formatPrice(item.input_cached)})</span>`;
                }
                // Note: onclick now calls window.setPreset because these are dynamically added
                row.innerHTML = `
                    <td><button class="model-name-btn" onclick="window.setPreset('${item.key}')">${item.name}</button></td>
                    <td>${inputCostDisplay}</td>
                    <td>${formatPrice(item.output)}</td>
                `;
                presetTableBody.appendChild(row);
            });
        }
        
        function updateTableSortVisualsAndData() {
            const thElements = document.querySelectorAll('.preset-table th');
            thElements.forEach(th => {
                th.setAttribute('aria-sort', 'none');
                th.querySelector('.sort-icon').textContent = '';
            });

            let activeThButtonId;
            if (currentSortColumn === 'name') activeThButtonId = elIds.sortByName;
            else if (currentSortColumn === 'input') activeThButtonId = elIds.sortByInput;
            else if (currentSortColumn === 'output') activeThButtonId = elIds.sortByOutput;

            if (activeThButtonId) {
                const activeTh = document.getElementById(activeThButtonId)?.closest('th');
                if (activeTh) {
                    activeTh.setAttribute('aria-sort', currentSortDirection);
                    activeTh.querySelector('.sort-icon').textContent = (currentSortDirection === 'ascending') ? '↑' : '↓';
                }
            }

            const sortedList = getSortedPresetList(currentSortColumn, currentSortDirection);
            renderTable(sortedList);
        }

        function sortTable(column) {
            if (currentSortColumn === column) {
                currentSortDirection = (currentSortDirection === 'ascending') ? 'descending' : 'ascending';
            } else {
                currentSortColumn = column;
                // Default direction for a new column (name: asc, numeric: asc)
                currentSortDirection = 'ascending';
            }
            updateTableSortVisualsAndData();
            updateUrlHash();
        }

        function applyStateFromHash() {
            if (!window.location.hash || window.location.hash === '#') {
                return; // No hash, use defaults
            }

            const params = new URLSearchParams(window.location.hash.substring(1));

            const inputTokensEl = document.getElementById(elIds.inputTokens);
            const cachedInputTokensEl = document.getElementById(elIds.cachedInputTokens);
            const outputTokensEl = document.getElementById(elIds.outputTokens);
            const inputCostEl = document.getElementById(elIds.inputCost);
            const cachedInputCostEl = document.getElementById(elIds.cachedInputCost);
            const outputCostEl = document.getElementById(elIds.outputCost);

            if (params.has(HASH_KEYS.inputTokens)) inputTokensEl.value = params.get(HASH_KEYS.inputTokens);
            if (params.has(HASH_KEYS.cachedInputTokens)) cachedInputTokensEl.value = params.get(HASH_KEYS.cachedInputTokens);
            if (params.has(HASH_KEYS.outputTokens)) outputTokensEl.value = params.get(HASH_KEYS.outputTokens);
            if (params.has(HASH_KEYS.inputCost)) inputCostEl.value = params.get(HASH_KEYS.inputCost);
            if (params.has(HASH_KEYS.cachedInputCost)) cachedInputCostEl.value = params.get(HASH_KEYS.cachedInputCost);
            if (params.has(HASH_KEYS.outputCost)) outputCostEl.value = params.get(HASH_KEYS.outputCost);

            const sortByFromHash = params.get(HASH_KEYS.sortBy);
            const sortDirFromHash = params.get(HASH_KEYS.sortDir);

            // Valid sort columns and directions
            const validSortCols = ['name', 'input', 'output'];
            const validSortDirs = ['ascending', 'descending'];

            if (sortByFromHash && validSortCols.includes(sortByFromHash) && 
                sortDirFromHash && validSortDirs.includes(sortDirFromHash)) {
                currentSortColumn = sortByFromHash;
                currentSortDirection = sortDirFromHash;
            } else if (sortByFromHash || sortDirFromHash) {
                // If partial or invalid sort params, revert to default to avoid broken state
                currentSortColumn = 'input';
                currentSortDirection = 'ascending';
            }
            // If no sort params in hash, defaults currentSortColumn/Direction are used
        }

        function handleSearchInput(event) {
            currentSearchTerm = event.target.value;
            updateTableSortVisualsAndData();
        }

        function handleSearchKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                // Find the first model button in the table and click it
                const firstModelButton = document.querySelector('#presetTableBody .model-name-btn');
                if (firstModelButton) {
                    firstModelButton.click();
                }
            }
        }

        function createPresetsTableStructure() {
            // Event listeners for sort buttons
            document.getElementById(elIds.sortByName).addEventListener('click', () => sortTable('name'));
            document.getElementById(elIds.sortByInput).addEventListener('click', () => sortTable('input'));
            document.getElementById(elIds.sortByOutput).addEventListener('click', () => sortTable('output'));

            // Event listeners for search input
            const searchInput = document.getElementById('modelSearch');
            searchInput.addEventListener('input', handleSearchInput);
            searchInput.addEventListener('keydown', handleSearchKeydown);

            // Initial render based on currentSortColumn and currentSortDirection
            // (which might have been updated by applyStateFromHash)
            updateTableSortVisualsAndData();
        }

        function handlePaste(event) {
            const text = (event.clipboardData || window.clipboardData).getData('text');
            const comboMatch = text.match(/([\d,]+)\s*input[, ]+([\d,]+)\s*output/i);
            if (comboMatch) {
                event.preventDefault();
                document.getElementById(elIds.inputTokens).value = comboMatch[1].replace(/,/g, '');
                document.getElementById(elIds.outputTokens).value = comboMatch[2].replace(/,/g, '');
                calculateCost();
                return;
            }
            const numMatch = text.match(/^\s*([\d,]+)\s*$/);
            if (numMatch && event.target.type === 'number') { // Ensure it's a number input
                event.preventDefault();
                event.target.value = numMatch[1].replace(/,/g, '');
                // Manually trigger 'input' event if needed, or just calculate
                calculateCost();
            }
        }

        // Load models from current-v1.json
        async function loadModels() {
            try {
                const response = await fetch('current-v1.json');
                const data = await response.json();

                // Convert prices array to object with id as the key
                presets = {};
                data.prices.forEach(model => {
                    presets[model.id] = {
                        name: model.name,
                        input: model.input,
                        output: model.output,
                        input_cached: model.input_cached
                    };
                });

                // Update the last updated date in the footer
                if (data.updated_at) {
                    document.getElementById('lastUpdated').textContent = data.updated_at;
                }

                return true;
            } catch (error) {
                console.error('Error loading models:', error);
                document.getElementById('lastUpdated').textContent = 'Unknown';
                return false;
            }
        }

        // Make setPreset globally accessible for dynamically created buttons
        window.setPreset = setPreset;

        // Initialize on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', async () => {
            await loadModels();        // 0. Load models from JSON first
            applyStateFromHash();      // 1. Apply state from URL hash first (updates globals)
            createPresetsTableStructure(); // 2. Setup table structure & initial render using (potentially updated) globals
            calculateCost();           // 3. Initial calculation and URL hash update based on current state

            // Add event listeners to form inputs
            const formInputs = [elIds.inputTokens, elIds.cachedInputTokens, elIds.outputTokens, elIds.inputCost, elIds.cachedInputCost, elIds.outputCost];
            formInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', calculateCost);
                // Add paste listener only to token inputs as per original logic
                if (id === elIds.inputTokens || id === elIds.cachedInputTokens || id === elIds.outputTokens) {
                     document.getElementById(id).addEventListener('paste', handlePaste);
                } else {
                     document.getElementById(id).addEventListener('paste', (e) => {
                         // Basic paste handling for cost inputs if desired, or just let browser handle
                         setTimeout(calculateCost, 0); // Recalculate after paste
                     });
                }
            });
            // Specific paste handler for inputTokens - remove from generic loop if it's only for one.
            // Original code had it only for inputTokens. Let's keep it for inputTokens only for now.
            document.getElementById(elIds.inputTokens).removeEventListener('paste', handlePaste); // remove generic one
            document.getElementById(elIds.inputTokens).addEventListener('paste', handlePaste); // add specific one

        });
    </script>
</body>
</html>

